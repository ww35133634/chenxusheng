"""
演示多线程的资源竞争问题
"""

# import threading
# import time
#
# list1 = [1,2,3]  # 全局变量 可变类型  不需要通过global去指定为全局变量进行操作
#
# def demo1(i):
#     list1.append(i)  # 子线程A list1 进行了操控
#     print('在demo1当中,,list1的值为:',list1)
#
# def demo2():
#     print('在demo2当中,,list1的值为:',list1)  # 子线程B list1 跟着看 不属于资源竞争
#
# def main():
#     # 创建两个子线程,,分别去执行demo1函数 和 demo2函数
#     # target是用来指定将来子线程去哪里执行代码
#     # args是传参的
#     t1 = threading.Thread(target=demo1,args=(4,))  # 子线程A去修改全局变量
#     t2 = threading.Thread(target=demo2)  # 子线程B去打印全局变量  是否是修改过后的值
#     t1.start()  # list1追加数据  4  >>> [1,2,3,4]
#     time.sleep(0.1)  # 手动加上一个延迟,,避免子线程B demo2 里面的代码先被执行
#     t2.start()  # [1,2,3,4]
# if __name__ == '__main__':
#     main()

# 多线程共享全局变量
"""
小明一家三口,,
一个电视机  >>> 全局变量 资源  资源竞争的问题  多个线程对同一个资源进行操作
小明爸    A        A
小明妈    跟着看   B
小明      跟着看   C
"""


"""
演示多线程都同一个全局变量进行操作,,,  演示资源竞争的问题
"""

import threading
import time

num1 = 0  # 全局变量 不可变类型

def demo1(a):  # 子线程A 对全局变量进行操作
    global num1
    for i in range(a):
        num1 += 1
    print('在demo1当中,,num1的值为:',num1)

def demo2(a):  # 子线程B 也要对 全局变量进行操作
    global num1
    for i in range(a):
        num1 += 1
    print('在demo2当中,,num1的值为:',num1)

def main():
    num2 = 1000000
    t1 = threading.Thread(target=demo1,args=(num2,))
    t2 = threading.Thread(target=demo2,args=(num2,))
    t1.start()
    t2.start()

    time.sleep(1.5)
    print('在主线程main当中,,,num1的值为:',num1)

if __name__ == '__main__':
    main()

"""
num1 = 0 , 子线程A 先去执行 num1 += 1  >>> 1000000  
 1000000   子线程B 再去执行 num1 += 1  >>> 2000000
                                main   >>> 2000000
进行多次了相同的值重复赋值给num1  导致了这样一个结果


在demo1当中,,num1的值为: 921438           
在demo2当中,,num1的值为: 1255572
在主线程main当中,,,num1的值为: 1255572

只有数据够大,, 才能够显示出多线程竞争资源的弊端 误差太大
    多线程共享全局变量的情况>>>>                       资源竞争的效果  也就更加的明显
num1 = 0 , 子线程A 先去执行 num1 += 1  >>> 100   
      100   子线程B 再去执行 num1 += 1  >>> 200




num1 = 0 , 子线程A 先去执行 num1 += 1  >>> 1
       1   子线程B 再去执行 num1 += 1  >>> 2
"""

"""
明确一个点,,,多线程  >>>  假的多任务 并发  1个cpu去处理  高速的切换 , 
主线程 子线程A 子线程B  分别去执行各自大代码,,, 
当cpu 去处理(执行) 子线程A 里面的代码 demo1 ,,    主线程  子线程B 处于等待状态 
0.001秒进行了切换
当cpu 去处理(执行) 子线程B 里面的代码在执行...       主线程  子线程A 处于一个等待状态
"""

"""
num1 += 1  实际上他一共会做三个操作 分解成 三句代码
1. 程序会获取到num1的值            0      
2. num1 + 1  得到一个新的结果      0+1= 1
3. 新的结果赋值给num1              num = 1  
cpu去执行
"""

"""
demo1     num1 = 100

demo2     num1  = 10


num1  = 10

"""
"""
一个整体如果开始执行,那么就必须执行完
原子性,,,避免这种中间部分切换导致的误差......

转账,,,原子性代表的
  A 100  B  20     50   
1. A 100 - 50 =  50    100
2. 50 >>>  B   回滚
3 B 20 + 50 = 70 
要么不执行,,要么三个步骤一起执行成功完毕
回滚,, 回到最初的状态

如果并不具备原子性,, 不允许
A 100 - 50 = 50
50  >>> B  出现问题,,  很崩溃
B  20 
"""

"""
同步 >>> 两个人 有规律的进行一件事,,, 你说一句 我说一句  你说完我再说 插嘴
左脚抬起来,,左脚到地上的时候,,
右脚才抬起来,,右脚到地上的时候
左脚才抬起来......

异步:
左脚抬起来了,,还没落地
右脚就要抬起来了,,,,
没有了规律 没有先后顺序,,, 跌倒....

资源竞争的问题
多线程共享全局变量  不会导致在关键时候被强行切换 ,,,,,,



"""

"""
互斥锁,
三俗的例子
一个厕所,,  一个共享的全局资源
A,,,进行到关键时候,,,  
B,,,我要进来了,,,
资源竞争的问题,,,,

A,,进入厕所 ,,, 锁上,,,
出来之前
B,,是不是就进不去了
资源竞争的问题,,

火车票
互斥锁的应用
1张火车票了,,,, 全局的资源  全局的变量
A,柜台购买    小明  上锁了,,关键确认,,,一系列的出票步骤  给钱了 出票,,,   锁释放 票重新出现 
B,网络购票    没票了,,,    有票了



下节课提前预告,,,
互斥锁解决多线程资源竞争问题>>>  解决关键时候,cpu强行切换的问题.......
"""


















































